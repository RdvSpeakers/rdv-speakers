ğŸš§ wip
- Olivier Poncet âœ…
- Sylvain Wallez âœ…
- SÃ©bastien Prunier âœ…
- Thierry Chantier âœ…
- FrÃ©dÃ©ric Cabestre âœ…
- Jeff Maury âœ…
- Julien Lengrand âœ…
- Sylvain RÃ©vÃ©rault âœ…
- Luc Sorel âœ…
- Benjamin Fichel ğŸš§
- Laurent Doguin âœ…

ğŸ–ï¸ Abstract FrÃ©dÃ©ric Cabestre:

Titre
=====

Types Classes, Traits, Implicits... Bigre !

Abstract
========

BrÃ¨ves de comptoir:                                                                                                                
 - Â« Les Type Classes c'est un peut comme des interfaces de Java quoi... Â»                                                         
 - Â« En Rust t'as pas de classes, mais les Traits, tu vois, c'est presque pareil. Â»                                                
 - Â« Les Implicits de Scala... pfiou... C'est pÃ©nible et j'y comprends rien. Â»                                                     
                                                                                                                                   
Alors oui... Mais non.                                                                                                             
                                                                                                                                   
Je vous propose de reprendre Ã  partir des bases : de l'apparition des Type Classes en Haskell et du problÃ¨me de polymorphisme 
qu'elles permettent de traiter. Nous tenterons une comparaison avec le concept objet de F-Bounded Polymorphism (HoulÃ , c'est quoi 
cette bestiole !). Puis nous verrons comment elles peuvent se mettre en Å“uvre Ã  l'aide de Scala et des si redoutÃ©s Implicits : 
les Â« Type classes tu pauvre Â» comme l'a dit Martin Odersky un jour. Et pour finir, nous essayerons de dÃ©terminer dans quelle 
mesure les Traits de Rust y sont assimilables... Ou pas.



ğŸ–ï¸ Abstract Jeff Maury

Titre (franÃ§ais): Voyageons dans les entrailles de GraalVM native image

GraalVM native image est un outil â€œmagiqueâ€ qui permet de gÃ©nÃ©rer un binaire natif Ã  partir de votre code Java. Cependant, la magie a ses limites et il serait intÃ©ressant de comprendre comment votre code Java est transformÃ© en code natif.
Je vous propose donc, en suivant la mÃ©thode de reverse engineering, de regarder sur un certain nombre dâ€™exemples (en partant du simple hello world et en allant vers du code plus reprÃ©sentatif), de dÃ©couvrir GraalVM native image de lâ€™intÃ©rieur et de maÃ®triser un peu mieux ce processus.


ğŸ–ï¸ Abstract Julien Lengrand:

Monitoring automatisÃ© de cave Ã  vin : Tales of Over Engineering


Je vis aux Pays-Bas, et pour survivre dans cette contrÃ©e lointaine j'importe du vin en large quantitÃ© plusieurs fois par an. Ayant achetÃ© une maison sans cave, j'ai dÃ» stocker mon vin sous le toit : clairement contre-intuitif. Ce talk est un aperÃ§u du systÃ¨me de monitoring que j'ai mis en place pour vÃ©rifier que mon vin est en lieu sÃ»r.

Mes spÃ©cifications pour le systÃ¨me sont simples : Apprendre une nouvelle techno Ã  chaque Ã©tape, stocker les donnÃ©es dans le cloud, introduire un maximum de dÃ©pendances (fun!) , tout en gardant un minimum de maintenance.

Nous naviguerons donc Ã  travers les diffÃ©rentes couches : Un driver en **C** et **JNI**, une cross-compilation pour **raspberry** sur **GitHub Actions**, un **microservice Helidon** Ã©crit en **Java** qui permet un changement dynamique des configurations et qui envoie les donnÃ©es vers un serveur **InfluxDb** couplÃ© Ã  des fonctions **Azure** pour les alertes. Nous ferons mÃªme un crochet par **FaunaDb** qui m'a servi de backup.
Pas d'inquiÃ©tude cependant, pas besoin de connaÃ®tre les technos mentionnÃ©es pour comprendre le talk!

Nous verrons ensemble si le systÃ¨me remplit son rÃ´le : avoir un diagramme complÃ¨tement plat, et probablement le moins FUN du monde :). 
